Index: projetCompil.g4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>grammar projetCompil;\r\n\r\ntinyLang : COMPIL NAMEPROG '(' ')' '{' decList START instsList '}';\r\n\r\n// ***********************déclarations**********************//\r\ndecList : dec decList|dec|;\r\ndec : type var ';' ;\r\ntype : INT | FLOAT|STRING;\r\nvar : ID ',' var | ID ;\r\n\r\n//************************ instructions***********************//\r\ninstsList : inst instsList| inst | ;\r\ninst : affect | ifinst | dowhile_inst| read | write;\r\n\r\n// affectation\r\naffect : ID AFF suite_operation ';';\r\nsuite_operation : operation|operation operateur suite_operation|operand;\r\noperation : operand operateur operand ;\r\noperateur : PLUS | MINUS |MUL | DIV ;\r\noperand : ID | val ;\r\nval : INTEGERVAL | FLOATVAL | STRINGVAL;\r\n\r\n// instruction if\r\nifinst : IF '(' cond ')' THEN '{' instsList '}' (|ELSE '{' instsList '}' ) ;\r\ncond : operand op operand ;\r\nop : SUP | INF | SUPE | INFE | DIF | EQ;\r\n\r\n//instruction do_while\r\ndowhile_inst : DO '{' instsList '}' WHILE '(' cond ')' ;\r\n\r\n// instruction read/write\r\nread :  SCAN '(' listID ')' ;\r\nwrite : PRINT '(' (STRINGVAL|listID) ')' ;\r\nlistID : ID ',' listID | ID ;\r\n\r\n\r\n//**************Skip*******************//\r\nWS:[\\n\\t] -> skip;\r\n//COMNT:  -> skip;\r\n\r\n//******************* Mots clés *******************//\r\n\r\nCOMPIL :'compil';\r\nINT : 'intCompil';\r\nFLOAT : 'floatCompil';\r\nSTRING : 'StringCompil';\r\nSCAN : 'scanCompil' ;\r\nPRINT : 'printCompil' ;\r\nSTART : 'start' ;\r\nIF : 'if';\r\nTHEN : 'then';\r\nELSE : 'else';\r\nDO : 'do';\r\nWHILE : 'while';\r\n\r\n\r\n//*********** Valeurs ******************* //\r\n\r\n\r\nINTEGERVAL : '0'|[+-]?[1-9][0-9]*;\r\nFLOATVAL : '0'|[+-]?[1-9][0-9]*('.'[0-9]*);\r\nSTRINGVAL : '.*';\r\nNAMEPROG : [A-Z][a-zA-Z0-9]*;\r\nID : [a-zA-Z][a-zA-Z0-9]*;\r\n\r\n\r\n\r\n// ************ opérateurs **************//\r\n\r\nAFF : '=';\r\nPLUS : '+';\r\nMINUS : '-';\r\nMUL : '*';\r\nDIV : '/';\r\nSUP : '>';\r\nINF : '<';\r\nSUPE : '>=';\r\nINFE : '<=';\r\nEQ : '==';\r\nDIF : '!=';\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/projetCompil.g4 b/projetCompil.g4
--- a/projetCompil.g4	(revision f8fce334b0dedb516f165df3783f0fa5aab53ffd)
+++ b/projetCompil.g4	(date 1617384449436)
@@ -3,7 +3,7 @@
 tinyLang : COMPIL NAMEPROG '(' ')' '{' decList START instsList '}';
 
 // ***********************déclarations**********************//
-decList : dec decList|dec|;
+decList : dec decList|dec;
 dec : type var ';' ;
 type : INT | FLOAT|STRING;
 var : ID ',' var | ID ;
@@ -18,7 +18,7 @@
 operation : operand operateur operand ;
 operateur : PLUS | MINUS |MUL | DIV ;
 operand : ID | val ;
-val : INTEGERVAL | FLOATVAL | STRINGVAL;
+val : INTEGERVAL | FLOATVAL | STRINGVAL | '-' INTEGERVAL | '-' FLOATVAL;
 
 // instruction if
 ifinst : IF '(' cond ')' THEN '{' instsList '}' (|ELSE '{' instsList '}' ) ;
@@ -57,7 +57,7 @@
 //*********** Valeurs ******************* //
 
 
-INTEGERVAL : '0'|[+-]?[1-9][0-9]*;
+INTEGERVAL : '0'|[1-9][0-9]* ;
 FLOATVAL : '0'|[+-]?[1-9][0-9]*('.'[0-9]*);
 STRINGVAL : '.*';
 NAMEPROG : [A-Z][a-zA-Z0-9]*;
Index: test.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>COMPIL NAMEPROG () { }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test.txt b/test.txt
--- a/test.txt	(revision f8fce334b0dedb516f165df3783f0fa5aab53ffd)
+++ b/test.txt	(date 1617356656674)
@@ -1,1 +1,9 @@
-COMPIL NAMEPROG () { }
\ No newline at end of file
+compil NAMEPROG () {
+intCompil t;
+floatCompil az;
+floatCompil s;
+StringCompil chaine;
+StringCompil r;
+start
+chaine = r;
+}
\ No newline at end of file
Index: src/Listener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.antlr.v4.runtime.ParserRuleContext;\r\nimport org.antlr.v4.runtime.tree.ErrorNode;\r\nimport org.antlr.v4.runtime.tree.TerminalNode;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.LinkedList;\r\n\r\npublic class Listener extends projetCompilBaseListener{\r\n\r\n\r\n\r\n        private TS table = new TS();\r\n        private LinkedList<String> errors = new LinkedList<>();\r\n        private HashMap<ParserRuleContext,Integer> types = new HashMap<>();\r\n\r\n\r\n\r\n        @Override public void exitTinyLang(projetCompilParser.TinyLangContext ctx) {\r\n                if(errors.size() == 0) { // no errors\r\n                        System.out.println(\"program compiled without errors!\");\r\n                        System.out.println(\"La table des symboles \");\r\n                        System.out.println(\"******************************************************\");\r\n                        for (int i = 0; i < table.getSize(); i++) {\r\n                                System.out.println(table.getElement(i).toString());\r\n                        }\r\n                        System.out.println(\"******************************************************\");\r\n                }\r\n                else\r\n                {\r\n                        System.out.println(\"program compiled with the following errors\");\r\n                        for (int i = 0; i < errors.size(); i++) {\r\n                                System.out.println(errors.get(i));\r\n                        }\r\n                }\r\n        }\r\n\r\n\r\n\r\n\r\n        @Override public void exitDecList(projetCompilParser.DecListContext ctx) {\r\n\r\n        }\r\n\r\n\r\n\r\n        @Override public void exitDec(projetCompilParser.DecContext ctx) {\r\n\r\n\r\n                projetCompilParser.VarContext vars = ctx.var();\r\n\r\n                for (;;vars = vars.var())\r\n                {\r\n                        String varType = vars.getChild(0).getText();\r\n                        String varName = vars.getChild(1).getText();\r\n\r\n                        if(table.containsElement(varName)) {\r\n                                errors.add(\"Double declaration of variable: \" + varName);\r\n                        }\r\n                        else\r\n                                table.addElement(new TS.Element(varName,true, varType));\r\n                        if(vars.var() == null)\r\n                                return;\r\n                }\r\n        }\r\n\r\n\r\n\r\n        @Override public void exitType(projetCompilParser.TypeContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitVar(projetCompilParser.VarContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitInstsList(projetCompilParser.InstsListContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitInst(projetCompilParser.InstContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitAffect(projetCompilParser.AffectContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitSuite_operation(projetCompilParser.Suite_operationContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitOperation(projetCompilParser.OperationContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitOperateur(projetCompilParser.OperateurContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitOperand(projetCompilParser.OperandContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitVal(projetCompilParser.ValContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitIfinst(projetCompilParser.IfinstContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitCond(projetCompilParser.CondContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitOp(projetCompilParser.OpContext ctx) { }\r\n\r\n\r\n        @Override public void exitDowhile_inst(projetCompilParser.Dowhile_instContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitRead(projetCompilParser.ReadContext ctx) { }\r\n\r\n\r\n\r\n        @Override public void exitWrite(projetCompilParser.WriteContext ctx) { }\r\n\r\n        @Override public void exitListID(projetCompilParser.ListIDContext ctx) { }\r\n\r\n\r\n        @Override public void enterEveryRule(ParserRuleContext ctx) { }\r\n\r\n        @Override public void exitEveryRule(ParserRuleContext ctx) { }\r\n\r\n        @Override public void visitTerminal(TerminalNode node) { }\r\n\r\n        @Override public void visitErrorNode(ErrorNode node) { }\r\n\r\n\r\n    }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Listener.java b/src/Listener.java
--- a/src/Listener.java	(revision f8fce334b0dedb516f165df3783f0fa5aab53ffd)
+++ b/src/Listener.java	(date 1617356108866)
@@ -5,18 +5,22 @@
 import java.util.HashMap;
 import java.util.LinkedList;
 
-public class Listener extends projetCompilBaseListener{
+public class Listener extends projetCompilBaseListener {
 
+        private int i;
 
+        private String entier = "intCompil";
+        private String reel = "floatCompil";
+        private String chaine = "StringCompil";
 
         private TS table = new TS();
         private LinkedList<String> errors = new LinkedList<>();
-        private HashMap<ParserRuleContext,Integer> types = new HashMap<>();
+        private HashMap<ParserRuleContext, String> types = new HashMap<>();
 
 
-
-        @Override public void exitTinyLang(projetCompilParser.TinyLangContext ctx) {
-                if(errors.size() == 0) { // no errors
+        @Override
+        public void exitTinyLang(projetCompilParser.TinyLangContext ctx) {
+                if (errors.size() == 0) { // no errors
                         System.out.println("program compiled without errors!");
                         System.out.println("La table des symboles ");
                         System.out.println("******************************************************");
@@ -24,9 +28,7 @@
                                 System.out.println(table.getElement(i).toString());
                         }
                         System.out.println("******************************************************");
-                }
-                else
-                {
+                } else {
                         System.out.println("program compiled with the following errors");
                         for (int i = 0; i < errors.size(); i++) {
                                 System.out.println(errors.get(i));
@@ -35,108 +37,239 @@
         }
 
 
-
-
-        @Override public void exitDecList(projetCompilParser.DecListContext ctx) {
+        @Override
+        public void exitDecList(projetCompilParser.DecListContext ctx) {
 
         }
 
 
-
-        @Override public void exitDec(projetCompilParser.DecContext ctx) {
+        @Override
+        public void exitDec(projetCompilParser.DecContext ctx) {
 
 
                 projetCompilParser.VarContext vars = ctx.var();
+                String varType = ctx.type().getText();
 
-                for (;;vars = vars.var())
-                {
-                        String varType = vars.getChild(0).getText();
-                        String varName = vars.getChild(1).getText();
+                for (; ; vars = vars.var()) {
+
+                        String varName = vars.getChild(0).getText();
 
-                        if(table.containsElement(varName)) {
-                                errors.add("Double declaration of variable: " + varName);
-                        }
-                        else
-                                table.addElement(new TS.Element(varName,true, varType));
-                        if(vars.var() == null)
+                        if (table.containsElement(varName)) {
+                                errors.add("Double declaration de la variable: " + varName);
+                        } else
+                                table.addElement(new TS.Element(varName, true, varType));
+                        if (vars.var() == null)
                                 return;
                 }
         }
 
+
+        @Override
+        public void exitType(projetCompilParser.TypeContext ctx) {
+        }
+
+
+        @Override
+        public void exitVar(projetCompilParser.VarContext ctx) {
+                for (int i = 0; i < table.getSize(); i++) {
+                        if (table.getElement(i).declared) {
+                                return;
+                        }
+                        System.out.println("variable " + ctx.ID().getText() + " non déclarée, ligne " + ctx.ID().getSymbol().getLine());
+
+
+                }
+
+        }
 
 
-        @Override public void exitType(projetCompilParser.TypeContext ctx) { }
+        @Override
+        public void exitInstsList(projetCompilParser.InstsListContext ctx) {
+        }
 
 
+        @Override
+        public void exitInst(projetCompilParser.InstContext ctx) {
+        }
 
-        @Override public void exitVar(projetCompilParser.VarContext ctx) { }
 
+        @Override
+        public void exitAffect(projetCompilParser.AffectContext ctx) {
 
+                System.out.println("le premier type est " + getCtxType(ctx.suite_operation()) + " le deuxieme type est " + table.getElement(ctx.ID().getText()).type);
+                if (!affectTypesCompatible(table.getElement(ctx.ID().getText()).type, getCtxType(ctx.suite_operation())))
+                        errors.add("incompatible types in affectation ligne : " + ctx.ID().getSymbol().getLine());
+                clearMap();
 
-        @Override public void exitInstsList(projetCompilParser.InstsListContext ctx) { }
+        }
 
 
+        @Override
+        public void exitSuite_operation(projetCompilParser.Suite_operationContext ctx) {
+                if(ctx.operation() == null)
+                        addCtxType(ctx,getCtxType(ctx.operand()));
+                else
+                {
+                        if(TypesCompatible(getCtxType(ctx.operation()),getCtxType(ctx.suite_operation())))
+                                addCtxType(ctx,getResultingType(getCtxType(ctx.operation()),getCtxType(ctx.suite_operation())));
+                        else {
+                                addCtxType(ctx, null);
+                        }
 
-        @Override public void exitInst(projetCompilParser.InstContext ctx) { }
+                }
+        }
 
 
 
-        @Override public void exitAffect(projetCompilParser.AffectContext ctx) { }
 
+        @Override
+        public void exitOperation(projetCompilParser.OperationContext ctx) {
+                if(TypesCompatible(getCtxType(ctx.operand(1)),getCtxType(ctx.operand(2))))
+                        addCtxType(ctx,getResultingType(getCtxType(ctx.operand(1)),getCtxType(ctx.operand(2))));
+                else {
+                        addCtxType(ctx, null);
+                }
+        }
 
 
-        @Override public void exitSuite_operation(projetCompilParser.Suite_operationContext ctx) { }
+        @Override
+        public void exitOperateur(projetCompilParser.OperateurContext ctx) {
+        }
 
 
+        @Override
+        public void exitOperand(projetCompilParser.OperandContext ctx) {
+                if (ctx.ID() != null)
+                        addCtxType(ctx, table.getElement(ctx.ID().getText()).type);
+                else
+                        addCtxType(ctx, getCtxType(ctx.val()));
+        }
 
-        @Override public void exitOperation(projetCompilParser.OperationContext ctx) { }
 
+        @Override
+        public void exitVal(projetCompilParser.ValContext ctx) {
+                addCtxType(ctx, getCtxType(ctx));
+        }
 
 
-        @Override public void exitOperateur(projetCompilParser.OperateurContext ctx) { }
+        @Override
+        public void exitIfinst(projetCompilParser.IfinstContext ctx) {
+        }
 
 
+        @Override
+        public void exitCond(projetCompilParser.CondContext ctx) {
+                clearMap();
+        }
 
-        @Override public void exitOperand(projetCompilParser.OperandContext ctx) { }
 
+        @Override
+        public void exitOp(projetCompilParser.OpContext ctx) {
+        }
 
 
-        @Override public void exitVal(projetCompilParser.ValContext ctx) { }
+        @Override
+        public void exitDowhile_inst(projetCompilParser.Dowhile_instContext ctx) {
+        }
 
 
+        @Override
+        public void exitRead(projetCompilParser.ReadContext ctx) {
+        }
 
-        @Override public void exitIfinst(projetCompilParser.IfinstContext ctx) { }
 
+        @Override
+        public void exitWrite(projetCompilParser.WriteContext ctx) {
+        }
 
+        @Override
+        public void exitListID(projetCompilParser.ListIDContext ctx) {
+        }
 
-        @Override public void exitCond(projetCompilParser.CondContext ctx) { }
 
+        @Override
+        public void enterEveryRule(ParserRuleContext ctx) {
+        }
 
+        @Override
+        public void exitEveryRule(ParserRuleContext ctx) {
+        }
 
-        @Override public void exitOp(projetCompilParser.OpContext ctx) { }
+        @Override
+        public void visitTerminal(TerminalNode node) {
+        }
 
-
-        @Override public void exitDowhile_inst(projetCompilParser.Dowhile_instContext ctx) { }
+        @Override
+        public void visitErrorNode(ErrorNode node) {
+        }
 
+        public LinkedList<String> getErrors() {
+                return errors;
+        }
 
+        private void addCtxType(ParserRuleContext ctx, String type) {
+                types.put(ctx, type);
+        }
 
-        @Override public void exitRead(projetCompilParser.ReadContext ctx) { }
+        private String getCtxType(ParserRuleContext ctx) {
+                return types.get(ctx);
+        }
 
+        private void clearMap() {
+                types.clear();
+        }
 
+        public TS getTable() {
+                return table;
+        }
 
-        @Override public void exitWrite(projetCompilParser.WriteContext ctx) { }
+        private boolean affectTypesCompatible(String premier, String second) {
+                if (premier == entier) {
+                        if (second == entier) {
+                                return true;
+                        } else {
+                                System.out.println("types incompatibles");
+                                return false;
+                        }
+                } else if (premier == reel) {
+                        if (second == entier || second == reel) {
+                                return true;
+                        } else {
+                                System.out.println("types incompatibles");
+                                return false;
+                        }
+                } else if (premier == chaine) {
+                        if (second == chaine) {
+                                return true;
+                        } else {
+                                System.out.println("types incompatibles");
+                                return false;
+                        }
+                }
+        return false;
+        }
 
-        @Override public void exitListID(projetCompilParser.ListIDContext ctx) { }
 
+        private boolean TypesCompatible(String premier, String second) {
+                if ((premier == entier || premier == reel) && (second == entier || second == reel)){
+                        return true;
+                }
+                return false;
 
-        @Override public void enterEveryRule(ParserRuleContext ctx) { }
+        }
 
-        @Override public void exitEveryRule(ParserRuleContext ctx) { }
 
-        @Override public void visitTerminal(TerminalNode node) { }
 
-        @Override public void visitErrorNode(ErrorNode node) { }
+        private String getResultingType(String premier, String second) {
+                if (premier == entier && second == entier ){
+                        return entier;
+                }
+                if (premier == reel || second == reel){
+                        return reel;
+                }
+                return null;
+        }
 
 
-    }
+}
 
